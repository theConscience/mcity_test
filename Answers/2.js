/* ************************************* */
/* 2. Как сравниваются переменные в js ? */
/* ************************************* */

// переменные сравниваются посредством операторов: ==, ===, !=, !==, >, <, >=, <= 
// в случае сравнения переменных разных типов - они автоматически приводятся к числу, 
// операторы сравнения возвращают булевы значения true или false

var a = 10;
var b = 100;

a < b;  // -> true
a > b;  // -> false

var c = 'a text';
var d = 'the Text';
var e = 'the Texxxxt';
var f = 'the Tex';

c > d;  // -> true, поскольку когда сравниваются многосимвольные строки то больше та, которая начинается с символа, который идёт позже в соответствующем алфавите.
d > e;  // -> false, если символы в строках одинаковые, то сравнение ведётся по первому встреченному интерпретатором различающемуся символу, в данном случае t и x.
f < e;  // -> true, если символы в строках одинаковые, но в одной из них букв больше, то наличие буквы делает строку больше чем её отсутствие.

var g = 'g';
var h = 'h';

g > h;  // -> true; но в случае одиночных символов, сравниваются их числовые коды в таблице unicode. Символы разного регистра - имеют разные коды.

// Когда сравниваются данные разных типов - все типы неявно приводятся к числам 
false > 1;  // -> false, т.к. false преобразуется к 0 (а true к 1), также к 0 приводятся пустые строки, а к 1 - непустые

// Приведение типов к числу не работает при строгом сравнении === или !===
'' === 0;  // -> false
1 !== true;  // -> true
// а также при нестрогом сравнении null или undefined с чем-либо
null == 0;  // -> false

// c null и undefined сравнение вообще работает нелогично и странно,
// поэтому если и сравнивать их с чем-то — то только используя строгое сравнение ===
// null и undefined равны друг другу и не равны больше ничему
null == undefined;  // -> true
undefined == undefined;  // -> true
null == null;   // -> true
// при срабатывании приведения к числу, null приводится к 0, а undefined - к NaN,
null > 1;  // -> false
isNaN(Number(undefined));  // -> true
undefined > 0;  // -> false
undefined < 0;  // -> false
undefined == 0;  // -> false
// но при нестрогом сравнении приведение к числу у null и undefined не срабатывает
null == 0;  // -> false
undefined == 0;  // -> false



// Есть ещё оператор typeof который позволяет выводить тип аргумента, возвращает строку с названием типа.
// Из странного - для null возвращает 'object' как и для объектов.

// Самое нелюбимое мной поведение - у строки '0', которая в сравнении:
'0' == true;  // возвращает false, т.к. преобразуется к Number, и получается 0 - который false
// а внутри оператора if ()
if ('0') console.log('\'0\' == true');  // срабатывает как true, и блок выполняется, т.к. тут строка приводится к Boolean, а непустая строка - это true


// Чтобы явно привести что-то к числу - можно сделать так:
Number('0');  // -> false
// Неявно приведение к числу происходит при использовании операторов сравнения, арифметических операторов,
// нестрогом сравнении, при исползовании унарного +, и при использовании бинарных операторов.

// Если используется бинарный + и один из аргументов - строка, то происходит неявное приведение к строке

// Чтобы явно привести что-то к булеву значению:
Boolean('0');  // -> true
// Чтобы неявно привести к булеву значению:
!!'0';  // -> true

// Чтобы явно привести к строке:
String(0);
// Чтобы неявно привести к строке:
0 + '';


// Когда сравниваются не примитивные типы данных а объекты - то всё происходит чуть сложнее
// если объекты одного типа - то они просто сравниваются по ссылке, а не по значению,
// т.е. каждый объект будет равен только сам себе
// а если объект сравнивается с каким-то примитивом, то его тип будет приводиться к примитиву.

// при булевом приведении типов все объекты, даже пустые - true
// это например происходит в такой ситуации:
if ([]) console.log('[] is true!');  // -> [] is true!

// при приведении объекта к примитивному типу посредством операторов сравнения или нестрогого равенства,
// объекты будут приводиться либо к строке либо к числу.