/* ****************************************************************** */
/* 5. Что такое context функции? В какой момент появляется контекст ? */
/* ****************************************************************** */ 

// контекст функции - это окружение, в котором функция вызывается,
// соответственно контекст появляется в момент вызова, в него входят:
// - область видимости текущей функции(объект активации) - т.е. все параметры, объявления переменных и вложенных функций
//   существующие на момент вызова,
// - цепочка областей видимости, которая записывается в функцию в момент объявления: от текущей функции наверх к глобальной
//   (если функция вложена в другие - то все их области видимости по порядку вложенности)
// - значение this - объект, в контексте которого выполняется функция.
//
// Часто под контекстом функции подразумевают только ключевое слово this, но это не вполне верно.
//
// По умолчанию функции вызываются в глобальном контексте, в браузере это window
// в node.js это global. В режиме strict - undefined. Соответственно значение this
// будет ссылаться на них.
//
// Если this используется вне функции - то в браузере это всегда window.
// Если this используется в самовызывающихся функциях (в браузере)- то он ссылается на window в обычном режиме,
// и на undefined с "use strict";
//
// Если одну и ту же функцию запускать в контексте разных объектов - она будет иметь разный this;
//
// Методы объектов могут обращаться через this к своим объектам, но в js любой метод в принципе можно вызвать 
// в контексте другого объекта, так что this может меняться.
//
// Чтобы в качестве this в функцию передался конкретный объект - нужно вызвать её через точку или квадратные скобки, как метод этого объекта.
// Если сохранить метод объекта в новую переменную и вызвать - контекст потеряется и this будет потерян.
//
// This внутри функции-конструктора, вызываемой через ключевое слово 'new' всегда будет ссылаться на создаваемый объект.

// "use strict"

const obj = {
    foo: 10,
    bar: function() {
        console.log(this);
    },
    baz: () => {
        console.log(this);
    }
}

const bar = obj.bar;

obj.bar();  // -> всегда возвращает объект obj
obj.baz();  // -> в зависимости от наличия "use strict" или его отсутствия возвращает undefined или объект Window соответственно, т.к. стрелочная функция, наследует this из лексического окружения
bar();  // -> в зависимости от наличия "use strict" или его отсутствия возвращает undefined или объект Window соответственно, т.к. контекст вызова теряется при сохранении метода в переменную и вызове

// Замыкания:
// если создать функцию внутри другой функции, то внутренняя функция будет содержать в
// своей цепочке областей видимости - область видимости внешней функции,
// и продолжит её содержать даже после того как внешняя отработает.
// Этот приём называется замыкание - и его можно использовать для эмуляции приватных свойств и хранения состояния.